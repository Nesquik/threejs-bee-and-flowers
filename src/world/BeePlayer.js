/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: hohastudios (https://sketchfab.com/hohastudios)
license: CC-BY-NC-SA-4.0 (http://creativecommons.org/licenses/by-nc-sa/4.0/)
source: https://sketchfab.com/3d-models/bee-00a889266c6743939b0d983e546d22b5
title: Bee
*/
/* eslint-disable no-unused-vars */

import React, { useRef, useEffect, useState, Suspense } from 'react'
// import { Physics, usePlane, useBox } from '@react-three/cannon'
// import { OrbitControls, OrthographicCamera, useCamera } from 'drei'
import { useGLTF } from '@react-three/drei/useGLTF'
import { Canvas, useThree, useFrame } from 'react-three-fiber'
import CameraControls from './CameraControls'
import { Physics, usePlane, useBox } from '@react-three/cannon'
import * as THREE from 'three'

import { useSphere } from '@react-three/cannon'

const SPEED = 5
const keys = { KeyW: 'forward', KeyS: 'backward', KeyA: 'left', KeyD: 'right', Space: 'jump' }
const moveFieldByKey = (key) => keys[key]
const direction = new THREE.Vector3()
const frontVector = new THREE.Vector3()
const sideVector = new THREE.Vector3()

const usePlayerControls = () => {
  const [movement, setMovement] = useState({ forward: false, backward: false, left: false, right: false, jump: false })
  useEffect(() => {
    const handleKeyDown = (e) => setMovement((m) => ({ ...m, [moveFieldByKey(e.code)]: true }))
    const handleKeyUp = (e) => setMovement((m) => ({ ...m, [moveFieldByKey(e.code)]: false }))
    document.addEventListener('keydown', handleKeyDown)
    document.addEventListener('keyup', handleKeyUp)
    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.removeEventListener('keyup', handleKeyUp)
    }
  }, [])
  return movement
}

const glTFBeePath = process.env.PUBLIC_URL + '/models/bee/scene.gltf'
console.log(glTFBeePath)

export default function BeePlayer(props) {
  const [beeRef] = useBox(() => ({ mass: 1, position: [0, 0, 0], ...props }))
  const [ref, api] = useSphere(() => ({ mass: 1, type: 'Dynamic', position: [0, 10, 0], ...props }))

  const { forward, backward, left, right, jump } = usePlayerControls()
  const { camera } = useThree()
  const velocity = useRef([0, 0, 0])
  if(beeRef.current) {

    console.log("player beeref")
    console.log(beeRef)
  }
  useEffect(() => void api.velocity.subscribe((v) => (velocity.current = v)), [])

  useFrame(() => {
    camera.position.copy(ref.current.position)    

    if (beeRef && beeRef.current) {
      const dist = 5
      let cwd = new THREE.Vector3()
      camera.getWorldDirection(cwd)
      cwd.multiplyScalar(dist)
      cwd.add(camera.position)
      beeRef.current.position.set(cwd.x, cwd.y, cwd.z)
      beeRef.current.setRotationFromQuaternion(camera.quaternion)
    }

    frontVector.set(0, 0, Number(backward) - Number(forward))
    sideVector.set(Number(left) - Number(right), 0, 0)
    direction.subVectors(frontVector, sideVector).normalize().multiplyScalar(SPEED).applyEuler(camera.rotation)
    api.velocity.set(direction.x, velocity.current[1], direction.z)
    // if (jump && Math.abs(velocity.current[1].toFixed(2)) < 0.05) {
    //   api.velocity.set(velocity.current[0], 10, velocity.current[2])
    // }
    // vel [0] = velocità in avanti
    // vel [1] = velocità in alto
    // vel [2] = velocità ai lati
    let velocitaAvanti = velocity.current[0]
    let velocitaAlto = velocity.current[1]
    let velocitaLato = velocity.current[2]
    // console.log(velocitaAvanti, velocitaAlto, velocitaLato)
    if (jump) {
      if (velocitaAlto < 3) {
        api.velocity.set(velocitaAvanti, 3, velocitaLato)
      }
    } else {
      // velocitaAlto -= 0.2
      // api.velocity.set(velocitaAvanti, velocitaAlto, velocitaLato)
    }
  })

  
  const { nodes, materials } = useGLTF(glTFBeePath)

  return (
    <Suspense fallback={null}>
      <group ref={beeRef} {...props} dispose={null}>
        {/* <CameraControls screenSpacePanning /> */}
        <group name="OSG_Scene">
          <group name="RootNode_(gltf_orientation_matrix)" rotation={[-Math.PI / 2, 0, 0]}>
            <group name="RootNode_(model_correction_matrix)">
              <group name="root">
                <group name="GLTF_SceneRootNode" rotation={[Math.PI / 2, 0, 0]}>
                  <group name="_0" position={[0, 0.25, 0.15]} scale={[0.51, 0.51, 0.51]}>
                    <mesh name="mesh_0" material={materials['Scene_-_Root']} geometry={nodes.mesh_0.geometry} />
                  </group>
                  {/* <!-- bottom --> */}
                  <group name="_1" position={[0, -0.1, 0.16]} scale={[0.53, 0.53, 0.53]}>
                    <mesh name="mesh_1" material={materials['Scene_-_Root']} geometry={nodes.mesh_1.geometry} />
                  </group>
                  {/* <!-- leg --> */}
                  <group name="_2" position={[0, -0.39, -0.11]} rotation={[-2.41, 0, 0]} scale={[0.44, 0.44, 0.44]}>
                    <mesh name="mesh_2" material={materials['Scene_-_Root']} geometry={nodes.mesh_2.geometry} />
                  </group>
                  <group name="_3" position={[0, 0.03, 0.01]}>
                    <mesh name="mesh_3" material={materials['Scene_-_Root']} geometry={nodes.mesh_3.geometry} />
                  </group>
                  <group name="_4" position={[0, -0.01, 0]}>
                    <mesh name="mesh_4" material={materials['Scene_-_Root']} geometry={nodes.mesh_4.geometry} />
                  </group>
                  <group name="_5" position={[0.01, 0.11, 0]}>
                    <mesh name="mesh_5" material={materials['Scene_-_Root']} geometry={nodes.mesh_5.geometry} />
                  </group>
                  <group name="_6">
                    <mesh name="mesh_6" material={materials['Scene_-_Root']} geometry={nodes.mesh_6.geometry} />
                  </group>
                  <group name="_7">
                    <mesh name="mesh_7" material={materials['Scene_-_Root']} geometry={nodes.mesh_7.geometry} />
                  </group>
                  <group name="_8">
                    <mesh name="mesh_8" material={materials['Scene_-_Root']} geometry={nodes.mesh_8.geometry} />
                  </group>
                  <group name="_9">
                    <mesh name="mesh_9" material={materials['Scene_-_Root']} geometry={nodes.mesh_9.geometry} />
                  </group>
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </Suspense>
  )
}

useGLTF.preload(glTFBeePath)
