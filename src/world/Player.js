/* eslint-disable no-unused-vars */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: hohastudios (https://sketchfab.com/hohastudios)
license: CC-BY-NC-SA-4.0 (http://creativecommons.org/licenses/by-nc-sa/4.0/)
source: https://sketchfab.com/3d-models/bee-00a889266c6743939b0d983e546d22b5
title: Bee
*/

import React, { useRef, useEffect, useState } from 'react'
import { Physics, usePlane, useBox } from '@react-three/cannon'
import { useGLTF } from '@react-three/drei/useGLTF'
import { Canvas, useThree, useFrame } from 'react-three-fiber'

import * as THREE from 'three'

import { useSphere } from '@react-three/cannon'
import Bee from './Bee'

const SPEED = 5
const keys = { KeyW: 'forward', KeyS: 'backward', KeyA: 'left', KeyD: 'right', Space: 'jump' }
const moveFieldByKey = (key) => keys[key]
const direction = new THREE.Vector3()
const frontVector = new THREE.Vector3()
const sideVector = new THREE.Vector3()

const usePlayerControls = () => {
  const [movement, setMovement] = useState({ forward: false, backward: false, left: false, right: false, jump: false })
  useEffect(() => {
    const handleKeyDown = (e) => setMovement((m) => ({ ...m, [moveFieldByKey(e.code)]: true }))
    const handleKeyUp = (e) => setMovement((m) => ({ ...m, [moveFieldByKey(e.code)]: false }))
    document.addEventListener('keydown', handleKeyDown)
    document.addEventListener('keyup', handleKeyUp)
    return () => {
      document.removeEventListener('keydown', handleKeyDown)
      document.removeEventListener('keyup', handleKeyUp)
    }
  }, [])
  return movement
}
function updatePositionForCamera(camera, beeRef) {
  // fixed distance from camera to the object
}

const Player = (props) => {
  const [beeRef] = useBox(() => ({ mass: 1, position: [0, 0, 0], ...props }))
  const [ref, api] = useSphere(() => ({ mass: 1, type: 'Dynamic', position: [0, 10, 0], ...props }))

  const { forward, backward, left, right, jump } = usePlayerControls()
  const { camera } = useThree()
  const velocity = useRef([0, 0, 0])
  useEffect(() => void api.velocity.subscribe((v) => (velocity.current = v)), [])

  useFrame(() => {
    camera.position.copy(ref.current.position)
    // beeRef.current.position = ref.current.position

    if (beeRef && beeRef.current) {
      const dist = 5
      let cwd = new THREE.Vector3()
      camera.getWorldDirection(cwd)
      cwd.multiplyScalar(dist)
      cwd.add(camera.position)
      beeRef.current.position.set(cwd.x, cwd.y, cwd.z)
      beeRef.current.setRotationFromQuaternion(camera.quaternion)
    }

    frontVector.set(0, 0, Number(backward) - Number(forward))
    sideVector.set(Number(left) - Number(right), 0, 0)
    direction.subVectors(frontVector, sideVector).normalize().multiplyScalar(SPEED).applyEuler(camera.rotation)
    api.velocity.set(direction.x, velocity.current[1], direction.z)
    // if (jump && Math.abs(velocity.current[1].toFixed(2)) < 0.05) {
    //   api.velocity.set(velocity.current[0], 10, velocity.current[2])
    // }
    // vel [0] = velocità in avanti
    // vel [1] = velocità in alto
    // vel [2] = velocità ai lati
    let velocitaAvanti = velocity.current[0]
    let velocitaAlto = velocity.current[1]
    let velocitaLato = velocity.current[2]
    // console.log(velocitaAvanti, velocitaAlto, velocitaLato)
    if (jump) {
      if (velocitaAlto < 3) {
        api.velocity.set(velocitaAvanti, 3, velocitaLato)
      }
    } else {
      // velocitaAlto -= 0.2
      // api.velocity.set(velocitaAvanti, velocitaAlto, velocitaLato)
    }
  })
  return (
    <>
      <mesh ref={ref} />
      <Bee beeRef={beeRef} />
    </>
  )
}
export default Player
